## Custom Repository 에 대해서
- 사용자 정의 리포지토리라고 무조건 Custom Repository에 때려박지 말자.
- 특화된 기능이 있으면(너무 조회 중심 코드가 길거나, DTO에 특화된 코드거나 등) 해당 기능에 맞춰서 새롭게 리포지토리를 쪼개서 하는 방식을 권장한다.

# Querydsl 페이징 연동에 관하여
### `fetch()` vs. `fetchResults()`
`fetchResults()`를 사용하면 콘텐츠용 쿼리도 날리고, 카운트용 쿼리도 날리게 된다.

### 복잡한 페이징 조회의 장점
- 전체 카운트를 조회하는 방법을 최적화할 수 있다.
  - 카운트 쿼리를 날릴 때 조인을 할 필요가 없다면 카운트를 할 때만 조인을 제거하는 방식을 사용할 수 있다.
  - `fetchResults()`의 방식은 조인이 다 붙어서 최적화를 할 수가 없다.
- 카운트 쿼리를 먼저 했는데, 만약 데이터가 없으면 아예 컨텐트 쿼리는 안 내보내는 방식으로도 최적화할 수 있다.
- 코드를 리팩토링할 수도 있다.

# CountQuery 최적화
- count 쿼리가 생략가능한 경우 스프링 데이터 라이브러리가 알아서 생략하는 기능을 제공한다.
  - 페이지 시작이면서 컨텐츠 사이즈가 페이지 사이즈보다 작을 때
  - 마지막 페이지일 때(offset + 컨텐츠 사이즈를 더해서 전체 사이즈 구함, 더 정확히는 마지막 페이지이면서 컨텐츠 사이즈가 페이지 사이즈보다 작을 때)
- `return PageableExecutionUtils.getPage(content, pageable, countQuery::fetchCount);`
  - 만약 count 쿼리를 생략해도 된다면 스프링이 알아서 세 번째 파라미터인 람다식을 실행하지 않는다.